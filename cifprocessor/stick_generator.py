import numpy as np
import os
import matplotlib.pyplot as plt
import glob
import pymatgen.analysis.diffraction.xrd as pm_xrd
import sys
from CIF_processor import get_comp, get_space_group, remove_parentheses
from pymatgen.io.cif import CifParser
import numpy as np
from collections import OrderedDict
from peak import Gauss
from peak_fitting import peak_fitting

##################### Generating Sticks #############################
def get_stick_dict_from_CIFs(pathstoCIFs, x_ray_wavelength=0.15406):

    Phases = {}
    for idx, cif in enumerate(pathstoCIFs):
        name = os.path.basename(cif)
        name = name[:name.index('.cif')]
        print('{}/{} '.format(idx+1, len(pathstoCIFs)) + name)
        Phases[name] = {}
        parser = CifParser(cif)
        try:
            structure = parser.get_structures()[0]
        except:
            print('Something went wrong when trying to get structures.')

        sticks = pm_xrd.XRDCalculator().get_pattern(structure=structure,
                two_theta_range=None).as_dict()
        Q = 4*np.pi/x_ray_wavelength*np.sin(np.deg2rad(sticks['x']/2))
        I = sticks['y']/max(sticks['y'])

        Phases[name]['Qs'] = Q
        Phases[name]['Is'] = I

    return Phases

def write_out_sticks(phase_dict, path, matsys=''):
    #assert path[-1] == '/', 'Add / in the end of path'
    if not os.path.isdir(path):
        os.mkdir(path)
    f = open(path / 'sticks.txt','w')
    g = open(path / 'names.txt','w')
    for idx, phase_key in enumerate(list(phase_dict)):
        print(phase_key)
        Q = phase_dict[phase_key]['Qs'].astype(float)
        I = phase_dict[phase_key]['Is'].astype(float)
        #paresr titeles
        f.write(f'Q{idx}={Q[0]}')
        g.write(f'Q{idx}={phase_key}\n')
        for q in Q[1:]:
            f.write(f',{q}')
        f.write('\n')
        f.write(f'P{idx}={I[0]}')
        for i in I[1:]:
            f.write(f',{i}')
        f.write('\n')
    f.close()
    g.close()

######################## Simplifying Sticks #############################
# All of these work based on the dictionary generated by the function above
def simplify_sticks(phase_dict, threshold, Q_range, method='error'):
    for idx, phase in enumerate(list(phase_dict)):
        trim_Q(phase)
        remove_small_peaks(phase)

def trimming_Qs(phase_dict, Q_range):
    Q_min = np.min(Q_range)
    Q_max = np.max(Q_range)
    to_be_removed = []
    for idx, Q in enumerate(phase_dict['Qs']):
        if not Q_min<Q<Q_max:
            to_be_removed.append(idx)
    phase_dict['Qs'] = np.delete(phase_dict['Qs'], to_be_removed)
    phase_dict['Is'] = np.delete(phase_dict['Is'], to_be_removed)

def remove_small_peaks(phase_dict, threshold, Q_range, method='error'):
    Is, Qs = sort_with_I(phase_dict)

    if method == 'error':
        recon = reconstruct(Qs, Is, Q_range)
        recon_wo_weakest = reconstruct(Qs[:-1], Is[:-1])
        if norm(recon - recon_wo_weakest) < thresold:
            Qs = Qs[:-1]
            Is = Is[:-1]
    elif method == 'number':
        Qs = Qs[:threshold]
        Is = Is[:threshold]

def resampling_sticks(phase_dict, peak_width, Q_range,
                      arr_size, max_peak, min_improv, plot=False):
    '''
    By reconstruct and resampling the stick pattern to trim down 
    the number of peaks
    '''
    phase_dict['Qs'] = [Q_to_ind(Q, Q_range, arr_size) 
                        for Q in phase_dict['Qs']]
    bnds = ((0, None), (10, None), (peak_width, 1.5*peak_width))
    reconstruction = recon_with_dict(phase_dict, peak_width, Q_range, arr_size)
    peak_ls = peak_fitting(reconstruction, max_peak, min_improv, bnds, plot=plot)
    phase_dict = get_phase_dict_from_peak_ls(peak_ls, Q_range, arr_size)
    return phase_dict

def recon_with_dict(phase_dict, peak_width, Q_range, arr_size):
    '''
    Reconstruct pattern by convoluting gaussian with stick pattern
    '''
    peak_ls = [Gauss(I, Q, peak_width) 
               for Q, I in zip(phase_dict['Qs'], phase_dict['Is'])] 
    recon = np.zeros(arr_size)
    for peak in peak_ls:
        recon += peak.distribution(arr_size)
    recon /= np.max(recon)
    return recon

def get_phase_dict_from_peak_ls(peak_ls, Q_range, arr_size):
    '''
    Construct the phase dictionary from a list of peaks object
    '''
    phase_dict = {}
    Qs = [ind_to_Q(peak.miu, Q_range, arr_size) for peak in peak_ls]
    Is = [peak.intensity for peak in peak_ls]
    Is = (np.array(Is)/np.max(Is)).tolist()
    phase_dict['Qs'] = np.array(Qs)
    phase_dict['Is'] = np.array(Is)
    return phase_dict

#### Helper functions ###
def sort_with_I(phase_dict):
    Qs = phase_dict['Qs']
    Is = phase_dict['Is']
    return zip(*sorted(zip(Is, Qs))[::-1])

def recon(Qs, Is, Q_range, sigma=8, arr_size=1024):
    r = np.zeros(arr_size)
    for Q, I in zip(Qs, Is):
        r += Guass(I, Q_to_ind(Q, Q_range), sigma).distribution(arr_size)
    return r

def Q_to_ind(Q, Q_range, arr_size):
    interval = (np.max(Q_range)-np.min(Q_range))/arr_size
    return int( (Q-np.min(Q_range))/interval )

def ind_to_Q(ind, Q_range, arr_size):
    interval = (np.max(Q_range)-np.min(Q_range))/arr_size
    return np.min(Q_range) + interval*ind

### Other Utility Functions ###

def get_name(fp, suffix='.cif'):
    file_name = os.path.basename(fp)
    return file_name[:file_name.index(suffix)]

def is_off_stochio(fp):
    return '.' in get_name(fp)

def preprocess_name(name):
    name = list(name)
    name.append(' ')
    name = ''.join(name)
    return name

def get_stochio_ratio(elements, name):
    if name[-1] != ' ':
        name = preprocess_name
    ratio = {} 
    elem_num = len(elements)
    try:
        for idx, elem in enumerate(elements):
            if idx != elem_num-1:
                num = name[name.index(elem)+len(elem):name.index(elements[idx+1])]
                if num.isspace() :
                    #stoichio[i][j]=1
                    ratio[elem]=1
                else:
                    #stoichio[i][j]=float(num)
                    ratio[elem]=float(num)
            else:
                num = name[name.index(elem)+len(elem):]
                if num == ' ' or num =='\n' or None:
                    #stoichio[i][j]=1
                    ratio[elem]=1
                else:
                    #stoichio[i][j]=float(num)
                    ratio[elem]=float(num)
        name = get_comp(parser)
    except:
        print('There is error prcoessing {} stoichiometric ratio'.format(name))
    return ratio

if __name__ == '__main__':

    compound = {} 

    elements = ['Ti', 'O']
    mat_sys = ''.join(elements)
    path = '/Users/mingchiang/Desktop/Code/data/CIF/{}/CIF/'.format(mat_sys)

    cif_ls = glob.glob(path + '*.cif')

#    for idx, cif in enumerate(cif_ls):
#        parser = CifParser(cif)
#        name = get_comp(parser)
#        full_name = get_name(cif)
#        compound['name'] = full_name
#        compound['space_group'] = get_space_group(parser)
#        name = list(name)
#        name.append(' ')
#        #name = remove_parentheses(name)
#        name = ''.join(name)
#        print(name) 
#
#        try:
#            structure = parser.get_structures()[0]
#        except:
#            print('Something wrong with {} for getting structures'.format(name))
#
#        ratio = get_stochio_ratio(elements, name)
#        print(ratio)
    phases = get_stick_dict_from_CIFs(cif_ls)
    for idx, phase in enumerate(list(phases)):
        trimming_Qs(phases[phase], (8, 45))
    print(phases)

